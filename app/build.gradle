plugins {
    alias(libs.plugins.android.application)
}

android {
    namespace 'com.orbitals.colorfilter'
    compileSdk 35

    defaultConfig {
        applicationId "com.orbitals.colorfilter"
        minSdk 30
        targetSdk 36
        versionCode 1
        versionName getVersionFromGit()

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        testInstrumentationRunnerArguments logLevel: 'debug'
        vectorDrawables {
            useSupportLibrary true
        }
    }
    if (System.getenv("SIGNING_STORE_FILE") != null && file(System.getenv("SIGNING_STORE_FILE")).exists()) {
        signingConfigs {
            release {
                storeFile file(System.getenv("SIGNING_STORE_FILE") ?: "")
                storePassword System.getenv("SIGNING_STORE_PASSWORD") ?: ""
                keyAlias System.getenv("SIGNING_KEY_ALIAS") ?: ""
                keyPassword System.getenv("SIGNING_KEY_PASSWORD") ?: ""
            }
        }
    }
    buildTypes {
        debug {
            debuggable true
            enableAndroidTestCoverage true
        }
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            if (System.getenv("SIGNING_STORE_FILE") != null && file(System.getenv("SIGNING_STORE_FILE")).exists()) {
                signingConfig signingConfigs.release
            }
        }
    }
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    buildFeatures {
        compose true
    }
    packagingOptions {
        resources {
            excludes.add('/META-INF/{AL2.0,LGPL2.1}')
        }
        jniLibs {
            useLegacyPackaging = false
        }
    }
    lint {
        checkDependencies true
        lintConfig file("lint.xml")
    }
}

dependencies {
    implementation libs.androidx.activity.compose
    implementation libs.androidx.appcompat
    implementation libs.androidx.exifinterface
    implementation libs.androidx.material3
    implementation libs.androidx.ui
    implementation libs.androidx.ui.graphics
    implementation libs.androidx.ui.tooling.preview
    implementation libs.opencv
    implementation platform(libs.androidx.compose.bom)
    androidTestImplementation libs.androidx.core
    androidTestImplementation libs.androidx.espresso.core
    androidTestImplementation libs.androidx.espresso.intents
    androidTestImplementation libs.androidx.junit
    androidTestImplementation libs.androidx.rules
    androidTestImplementation libs.androidx.runner
    androidTestImplementation libs.androidx.ui.test.junit4
    androidTestImplementation libs.androidx.uiautomator
    androidTestImplementation libs.mockito.android
    androidTestImplementation platform(libs.androidx.compose.bom)
    debugImplementation libs.androidx.ui.test.manifest
    debugImplementation libs.androidx.ui.tooling
    debugImplementation libs.leakcanary.android
}

tasks.withType(Test).configureEach {
    jacoco.includeNoLocationClasses = true
    jacoco.excludes = ['jdk.internal.*']
}

def coverageSourceDirs = [
        'src/main/java'
]

tasks.register('jacocoTestReport', JacocoReport) {
    dependsOn 'createDebugCoverageReport'
    reports {
        xml.required.set(true)
        html.required.set(true)
        csv.required.set(false)
        xml.outputLocation.set(layout.buildDirectory.file("reports/jacoco/report.xml"))
        html.outputLocation.set(layout.buildDirectory.dir("reports/jacoco/html"))
    }

    sourceDirectories.setFrom(files(coverageSourceDirs))
    classDirectories.setFrom(fileTree(
            dir: layout.buildDirectory.dir("intermediates/classes/debug").get().asFile,
            excludes: ['**/R.class',
                       '**/R$*.class',
                       '**/BuildConfig.*',
                       '**/Manifest*.*']
    ))

    doFirst {
        executionData.setFrom(fileTree(
                dir: layout.buildDirectory.get().asFile,
                includes: [
                        'outputs/code-coverage/connected/*coverage.ec'
                ]
        ))
    }
}

configurations.configureEach {
    if (name.toLowerCase().contains("jacoco")) {
        resolutionStrategy.eachDependency {
            if (requested.group == "net.bytebuddy" && requested.name == "byte-buddy") {
                useVersion("1.14.14") // last version Jacoco instruments reliably
                because("Jacoco cannot transform Byte Buddy >= 1.17.x yet")
            }
        }
    }
}

static def getVersionFromGit() {
    def process = new ProcessBuilder('git', 'describe', '--tags', '--long', '--match', 'v[0-9]*.[0-9]*.[0-9]*')
            .redirectErrorStream(true)
            .start()
    process.waitFor()
    def stdout = new BufferedReader(new InputStreamReader(process.getInputStream())).getText()
    def describe = stdout.trim()

    // Parse the git describe output (format: v1.2.3-5-g3c4d5e6)
    def matcher = describe =~ /v(\d+)\.(\d+)\.(\d+)(?:-(\d+)-g([a-f0-9]+))?/
    if (matcher.matches()) {
        def major = matcher.group(1)
        def minor = matcher.group(2)
        def patch = matcher.group(3)
        def commitCount = matcher.group(4)

        if (commitCount && commitCount != "0") {
            // We have commits after the tag, use dev format
            return "${major}.${minor}.${patch}-dev${commitCount}"
        } else {
            // Exact tag match
            return "${major}.${minor}.${patch}"
        }
    } else {
        // Fallback if no tag found
        return "0.1.0-dev"
    }
}
